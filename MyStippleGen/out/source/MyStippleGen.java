/* autogenerated by Processing revision 1293 on 2024-07-20 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import controlP5.*;
import processing.pdf.*;
import processing.dxf.*;
import processing.svg.*;
import controlP5.*;
import java.util.Random;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class MyStippleGen extends PApplet {

/**

 StippleGen_3

 SVG Stipple Generator, v. 3.0
 Copyright (C) 2024 by Christophe Floutier

 based on :
 
 SVG Stipple Generator, v. 2.50
 Copyright (C) 2019 by Windell H. Oskay, www.evilmadscientist.com

 Full Documentation: http://wiki.evilmadscientist.com/StippleGen
 Blog post about the release: http://www.evilmadscientist.com/go/stipple2

 An implementation of Weighted Voronoi Stippling:
 http://mrl.nyu.edu/~ajsecord/stipples.html

 *******************************************************************************


/*  
 * 
 * This is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * http://creativecommons.org/licenses/LGPL/2.1/
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */





 
DrawingData data;
DataGUI dataGui;
DrawingGenerator drawer;
//SourceFiles sourceFilesGui;
PGraphics current_graphics;

ControlP5 cp5;

public void setup() 
{
  /* size commented out by preprocessor */;

  drawer =  new DrawingGenerator();

  data = new Data();
  dataGui = new DataGUI();
  
  setupControls();
   
  data.LoadJson("./Saved/default.json");
  data.name = "default";

  dataGui.setGUIValues();
  surface.setResizable(true);
}

public void setupControls()
{ 
  cp5 = new ControlP5(this); 
  cp5.getTab("default").setLabel("Hide GUI");

  dataGui.setupControls( cp5);     
  addFileTab();
}

public void draw()
{
  start_draw();

  if (data.changed)
  {
    dataGui.updateUI();
  }
  
  drawer.center = new PVector(width/2, height/2);

  drawer.data = data;
  drawer.draw();

  end_draw();
}
  //<>//


class Data
{
  String name = "";

  boolean changed = true;
  
  String tab_name;

  Style style = new Style();
  DataMain main = new DataMain();  
  
  float width = 800;
  float height = 600;

  public void setSize(float width, float height)
  {
    if (this.width != width)
    {
      changed = true;
      this.width = width;
    }

    if (this.height != height)
    {
      changed = true;
      this.height = height;
    }
  }

  public void LoadJson(String path)
  {
    JSONObject json = loadJSONObject(path);

    style.LoadJson(json.getJSONObject("Style"));
    main.LoadJson(json.getJSONObject("Main"));
  }

  public void SaveJson(String path)
  {
    JSONObject json = new JSONObject();

    json.setJSONObject("Style", style.SaveJson());
    json.setJSONObject("Main", main.SaveJson());

    saveJSONObject(json, path);
  }
}

class DataGUI 
{
  MainGUI main = new MainGUI(); 
  StyleGUI style = new StyleGUI();

  public void updateUI()
  {
    if (!data.changed)
      return;

    main.update();
    style.update();
  }

  public void setupControls(ControlP5 cp5)
  { 
    cp5.addTab("Style");
    cp5.addTab("Main");

    main.setupControls( cp5 );    
    style.setupControls( cp5 );    

    cp5.getTab("Main").bringToFront();
  }

  public void setGUIValues()
  {
    style.setGUIValues();
    main.setGUIValues();
  }
}

class DataMain
{
  int NbDots = 100;
  int seed; 

  public void setSeed()
  {
    seed = (int) random(0, 100000000);
  }

  public void LoadJson(JSONObject src)
  {
    if (src == null)
      return;

    NbDots = src.getInt("NbDots", NbLines);
   
  }

  public JSONObject SaveJson()
  {
    JSONObject dest = new JSONObject();

    dest.setInt("NbDots", NbDots);

    return dest;
  }
}

class MainGUI extends UI_Panel
{
  DataMain main;
  Slider NbDots;

  public void setGUIValues()
  {
    NbDots.setValue(main.NbDots);
  }

  public void setupControls(ControlP5 cp5)
  {
    super.Init("Main", cp5);

    main = data.main;

    addLabel("Page");
    NbDots = addSlider("NbLines", "Nb of Dots", main, 1, 1000, true);
  }

  public void update()
  {
    // seedLabel.setText("seed : " + main.seed);
  }
}



class Style
{
  ColorRef lineColor = new ColorRef(color(255, 255, 255), "lineColor");
  ColorRef backgroundColor = new ColorRef(color(0, 0, 0), "backgroundColor");
  float lineWidth = 1;

  public void LoadJson(JSONObject src)
  {
    if (src == null)
      return;

    backgroundColor.LoadJson(src);
    lineColor.LoadJson(src);

    lineWidth = src.getFloat("lineWidth", lineWidth);
  }

  public JSONObject SaveJson()
  {
    JSONObject dest = new JSONObject();

    backgroundColor.SaveJson(dest);
    lineColor.SaveJson(dest);

    dest.setFloat("lineWidth", lineWidth);

    return dest;
  }
}


class StyleGUI extends GUIPanel
{
  Slider lineWidth;
  Style style;
  ColorGroup backgroundColor;
  ColorGroup lineColor;

  public void setGUIValues()
  {
    lineWidth.setValue(style.lineWidth);
  }

  public void setupControls(ControlP5 cp5)
  {
    style = data.style;
    super.Init("Style", cp5);
    lineWidth = addSlider("lineWidth", "Line Width", style, 0, 5, false);
    lineColor = addColorGroup("Line Color", style.lineColor);
    backgroundColor = addColorGroup("background Color", style.backgroundColor);
  }

  public void update()
  {
 
  }
}

class ColorButton
{
  int col;

  Button bt = null;
  ColorRef refColor = null;

  ColorButton(int col)
  {
    this.col = col;
  }

  public void init(GUIPanel panel, ColorRef refColor)
  {
    bt = cp5.addButton("colorbt"+ indexControler)
      .setPosition(panel.xPos, panel.yPos)
      .setSize(20, 20)
      .setLabel("")
      .moveTo(panel.pageName)
      .setColorBackground(col);

    indexControler++;
    panel.xPos += 22;


    bt.plugTo(this, "onCLic");
    this.refColor = refColor;
  }

  public void onCLic()
  {
    refColor.col = this.col;
  }
}

class ColorGroup
{
  ColorRef colorRef;
  String name;

  int[][] colors = {
    { 255, 255, 255  },
  
    { 255, 205, 210 }, // rose
    
    { 81, 46, 95   }, 
    { 155, 89, 182  }, 
    { 235, 222, 240 }, 
    { 21, 67, 96 }, 
    { 127, 179, 213 }, 
    { 33, 97, 140 }, 
    { 93, 173, 226 }, 
    { 14, 98, 81 }, 
    { 39, 174, 96 }, 
    { 88, 214, 141 }, 
    
    { 255, 245, 157 }, // jaunes
    { 253, 216, 53  }, 
      
    { 251, 140, 0},  // orange
    { 255, 87, 34 },  // 
    {  191, 54, 12   },  // rouges
    { 100, 30, 22 }, 
    { 192, 57, 43 }, 
    { 148, 49, 38  }, 
    
    { 93, 64, 55  }, //marrons
    { 62, 39, 35  }, 

    
    { 174, 182, 191 }, // gris
    { 44, 62, 80 }, 
    { 23, 32, 42 }, 
    { 10, 14, 19 }, 
    { 0, 0, 0  }
  };

  ColorGroup(ColorRef colorRef, String name)
  {
    this.colorRef = colorRef;
    this.name = name;
  }

  public void Init(GUIPanel panel)
  {
    panel.addLabel(name);
    
    for(int i = 0; i< colors.length; i++){
        if (i != 0 && (i%8) == 0)
        {
          panel.yPos += 25;
          panel.xPos = StartX;
        }
        
        int[] colorValues = colors[i];
        new ColorButton(color(colorValues[0], colorValues[1],colorValues[2])).init(panel, colorRef);
        
    }
    
     panel.yPos += 25;
     panel.xPos = StartX;
  }
}


class ColorRef
{
  ColorRef(int col, String name)
  {
    this.col = col;
    this.name = name;
  }

  int col;
  String name;

  public void LoadJson(JSONObject src)
  {
    col = src.getInt(name, col);
  }

  public void SaveJson(JSONObject dest)
  {
    dest.setInt(name, col);
  }
}

public void addFileTab()
{
  cp5.addTab("Files");
  
  println("addFileTab");

  float xPos = 0;
  float yPos = 20;

  int widthButton = 100;
  int heightButton = 20;

  cp5.addButton("LoadJson")
    .setPosition(xPos, yPos)
    .setSize(widthButton, heightButton)
    .moveTo("Files");        

  xPos += widthButton;

  cp5.addButton("SaveJson")
    .setPosition(xPos, yPos)
    .setSize(widthButton, heightButton)
    .moveTo("Files");    

  yPos += heightButton;
  xPos = 0;

  cp5.addButton("ExportPDF")
    .setPosition(xPos, yPos)
    .setSize(widthButton, heightButton)
    .moveTo("Files");      

  xPos += widthButton;

/*  cp5.addButton("ExportDXF")
    .setPosition(xPos, yPos)
    .setSize(widthButton, heightButton)
    .moveTo("Files");      

  xPos += widthButton;
*/

  cp5.addButton("ExportSVG")
    .setPosition(xPos, yPos)
    .setSize(widthButton, heightButton)
    .moveTo("Files");    

  xPos += widthButton;
}

public void LoadJson()
{
  print("LoadJson");
  
  File file = new File(".");
  selectInput("Select data file ", "loadSelected", file);
}

public void loadSelected(File selection) 
{
  if (selection == null) 
  {
  } else 
  {
    data.LoadJson(selection.getAbsolutePath());
    data.name = selection.getName();
    data.name = data.name.substring(0, data.name.length() - 5);
   
    dataGui.setGUIValues();
  }
}

public void SaveJson()
{
  selectInput("Save data file ", "saveSelected");
}

public void saveSelected(File selection) 
{
  if (selection == null) 
  {
  } else 
  {
    String path = selection.getAbsolutePath();
    if (path.length() < 5 || !path.substring(path.length() - 5).equals(".json"))
      path = path + ".json";

    data.SaveJson(path);
    
    data.name = selection.getName();
    data.name = data.name.substring(0, data.name.length() - 5);
  
  }
}

boolean record = false;
int mode  = 0;

String fileName = "";
public void ExportPDF()
{
  record = true;
  mode = 0;
}

public void ExportDXF()
{
  record = true;
  mode = 1;
}  

public void ExportSVG()
{
  record = true;
  mode = 2;
}

public void start_draw()
{
  if (record) 
  {

    String name = data.name;
    if (name == "")
      name = "Perlin_Mountain";
      
    float sizeMultiplier = 1;
    
    println(name);
      
   // sizeMultiplier = (float) width  / 28;
      
      
    float newWidth = width * sizeMultiplier;
    float newheight = height * sizeMultiplier;
      
    fileName = "Export/"+ name + "_" + year() + "-" + month() + "-" + day() + "_" + hour() + "-" + minute() + "-" + second(); 
    
    if (mode == 0)
       current_graphics = createGraphics((int)newWidth, (int)newheight, PDF, fileName+ ".pdf");       
    else if (mode == 1)
      current_graphics = createGraphics((int)newWidth, (int)newheight, DXF, fileName+ ".dxf");       
    else if (mode ==2)
      current_graphics = createGraphics((int)newWidth, (int)newheight, SVG, fileName+ ".svg");       
    
    data.setSize(newWidth, newheight); 
    
    current_graphics.beginDraw();
    current_graphics.strokeWeight(data.style.lineWidth*sizeMultiplier);
    
    current_graphics.rotate(-PI/2);
   
     current_graphics.translate(-newWidth,newheight/2);
    
    
  } else {
    
    current_graphics = g;

    background(data.style.backgroundColor.col);
    strokeWeight(data.style.lineWidth);

    stroke(data.style.lineColor.col);
    
    current_graphics = g;

    data.setSize(width, height);
  } 
}

public void end_draw()
{
  if (record) 
  {
    current_graphics.dispose();
    current_graphics.endDraw();
    record = false;
  }
}

int indexControler = 0;

static final int StartX = 20;
static final int StartY = 20;

class GUIPanel implements ControlListener
{
  String pageName;
  
  float xPos = 0;
  float yPos = 0;

  int xspace = 15;

  int widthCtrl = 300;
  int heightCtrl = 20;

  public void Init(String pageName)
  {
    this.pageName = pageName;
    
    cp5.addListener(this);

    yPos = StartY;
    xPos = StartX;
  }

  public void onUIChanged()
  {
    data.changed = true;
  }

  public void controlEvent(ControlEvent theEvent) {
    onUIChanged();
  }

  public Textlabel addLabel(String content)
  {
    yPos += 10;

    Textlabel l = cp5.addTextlabel("Label" + indexControler)
      .setText(content)
      .setPosition(xPos, yPos)
      .setSize(100, heightCtrl)
      .moveTo(pageName);

    yPos += 15;

    indexControler++;

    return l;
  }


  public Slider addIntSlider(String field, String label, Object data_Class, int min, int max, boolean horizontal)
  {
    Slider s = addSlider( field, label, data_Class, min, max, horizontal);
    int nbTicks = (int) (max - min + 1);
    s.setNumberOfTickMarks(nbTicks);
    s.showTickMarks(false);
    s.snapToTickMarks(true);

    return s;
  }


  public Slider addSlider(String field, String label, Object data_Class, float min, float max, boolean horizontal)
  {
    Slider s = cp5.addSlider(data_Class, field)
      .setLabel(label)
      .setPosition(xPos, yPos)
      .setSize(widthCtrl, heightCtrl)
      .setRange(min, max)
      .moveTo(pageName);

    if (horizontal)
    {
      xPos += xspace + widthCtrl;
    } else
    {
      yPos+=heightCtrl+2;
      xPos = StartX;
    }

    controlP5.Label l = s.getCaptionLabel();
    l.getStyle().marginTop = 0; //move upwards (relative to button size)
    l.getStyle().marginLeft = -65; //move to the right

    return s;
  }

  public Toggle addToggle(String name, String label, Object data_Class)
  {
    Toggle t = cp5.addToggle(data_Class, name)
      .setLabel(label)
      .setPosition(xPos, yPos)
      .setSize(100, heightCtrl)
      .setMode(ControlP5.SWITCH)
      .moveTo(pageName);

    CColor controlerColor = t.getColor();
    int tmp = controlerColor.getActive();
    controlerColor.setActive( controlerColor.getBackground());
    controlerColor.setBackground(tmp);

    yPos+=heightCtrl+2;

    //t.setLabel("The Toggle Name");
    controlP5.Label l = t.getCaptionLabel();
    l.getStyle().marginTop = -heightCtrl + 2; //move upwards (relative to button size)
    l.getStyle().marginLeft = 10; //move to the right

    return t;
  }

  public ColorPicker addColorPicker(String name, String label, Object data_Class)
  {
    addLabel(label);

    ColorPicker cp = cp5.addColorPicker(data_Class, name)

      .setPosition(xPos, yPos)
      .setSize(100, heightCtrl*3)
      .moveTo(pageName);

    yPos+=heightCtrl*3;

    return cp;
  }


  public ColorGroup addColorGroup(String name, ColorRef colorRef)
  {
    ColorGroup grp = new ColorGroup(colorRef, name );

    grp.Init(this);

    return grp;
  }

  public Button addButton(String name)
  {
    Button bt = cp5.addButton(name + indexControler)
      .setPosition(xPos, yPos)
      .setLabel(name)
      .setSize(100, heightCtrl)
      .moveTo(pageName);

    indexControler++;
    yPos+=heightCtrl+5;

    return bt;
  }
  
  public void start()
  {
    xPos = 20;
    yPos = 20;
  }
  
  public void nextLine()
  {
    xPos = 20;
    yPos += heightCtrl + 1;
    
    }
}




//////////////////////////////////////////////////////////////

// PERLIN NOISE, rewriten by cfloutier to change the way cosinus is computed

// [toxi 040903]
// octaves and amplitude amount per octave are now user controlled
// via the noiseDetail() function.

// [toxi 030902]
// cleaned up code and now using bagel's cosine table to speed up

// [toxi 030901]
// implementation by the german demo group farbrausch
// as used in their demo "art": http://www.farb-rausch.de/fr010src.zip

static final int PERLIN_YWRAPB = 4;
static final int PERLIN_YWRAP = 1<<PERLIN_YWRAPB;
static final int PERLIN_ZWRAPB = 8;
static final int PERLIN_ZWRAP = 1<<PERLIN_ZWRAPB;
static final int PERLIN_SIZE = 4095;

int perlin_octaves = 4; // default to medium smooth
float perlin_amp_falloff = 0.5f; // 50% reduction/octave

// [toxi 031112]
// new vars needed due to recent change of cos table in PGraphics
int perlin_PI;
static final int perlin_TWOPI = 65536;

float[] perlin_cosTable;
float[] perlin;

Random perlinRandom;

/**
 */
public float noise(float x) {
  // is this legit? it's a dumb way to do it (but repair it later)
  return noise(x, 0f, 0f);
}

/**
 */
public float noise(float x, float y) {
  return noise(x, y, 0f);
}


/**
 * ( begin auto-generated from noise.xml )
 *
 * Returns the Perlin noise value at specified coordinates. Perlin noise is
 * a random sequence generator producing a more natural ordered, harmonic
 * succession of numbers compared to the standard <b>random()</b> function.
 * It was invented by Ken Perlin in the 1980s and been used since in
 * graphical applications to produce procedural textures, natural motion,
 * shapes, terrains etc.<br /><br /> The main difference to the
 * <b>random()</b> function is that Perlin noise is defined in an infinite
 * n-dimensional space where each pair of coordinates corresponds to a
 * fixed semi-random value (fixed only for the lifespan of the program).
 * The resulting value will always be between 0.0 and 1.0. Processing can
 * compute 1D, 2D and 3D noise, depending on the number of coordinates
 * given. The noise value can be animated by moving through the noise space
 * as demonstrated in the example above. The 2nd and 3rd dimension can also
 * be interpreted as time.<br /><br />The actual noise is structured
 * similar to an audio signal, in respect to the function's use of
 * frequencies. Similar to the concept of harmonics in physics, perlin
 * noise is computed over several octaves which are added together for the
 * final result. <br /><br />Another way to adjust the character of the
 * resulting sequence is the scale of the input coordinates. As the
 * function works within an infinite space the value of the coordinates
 * doesn't matter as such, only the distance between successive coordinates
 * does (eg. when using <b>noise()</b> within a loop). As a general rule
 * the smaller the difference between coordinates, the smoother the
 * resulting noise sequence will be. Steps of 0.005-0.03 work best for most
 * applications, but this will differ depending on use.
 *
 * ( end auto-generated )
 *
 * @webref math:random
 * @param x x-coordinate in noise space
 * @param y y-coordinate in noise space
 * @param z z-coordinate in noise space
 * @see PApplet#noiseSeed(long)
 * @see PApplet#noiseDetail(int, float)
 * @see PApplet#random(float,float)
 */
public float noise(float x, float y, float z) {
  if (perlin == null) {
    if (perlinRandom == null) {
      perlinRandom = new Random();
    }
    perlin = new float[PERLIN_SIZE + 1];
    for (int i = 0; i < PERLIN_SIZE + 1; i++) {
      perlin[i] = perlinRandom.nextFloat(); //(float)Math.random();
    }

    perlin_cosTable = new float[perlin_TWOPI];
    perlin_PI = perlin_TWOPI >> 1;
    for (int i = 0; i < perlin_TWOPI; i++)
    {
      float angle = (float)i/perlin_PI;

      perlin_cosTable[i] =  cos( angle * PI );
    }
  }

  if (x<0) x=-x;
  if (y<0) y=-y;
  if (z<0) z=-z;

  int xi=(int)x, yi=(int)y, zi=(int)z; //<>//
  float xf = x - xi;
  float yf = y - yi;
  float zf = z - zi;
  float rxf, ryf;

  float r=0;
  float ampl=0.5f;

  float n1, n2, n3;

  for (int i=0; i<perlin_octaves; i++) {
    int of=xi+(yi<<PERLIN_YWRAPB)+(zi<<PERLIN_ZWRAPB);

    rxf=noise_fsc(xf);
    ryf=noise_fsc(yf);

    n1  = perlin[of&PERLIN_SIZE];
    n1 += rxf*(perlin[(of+1)&PERLIN_SIZE]-n1);
    n2  = perlin[(of+PERLIN_YWRAP)&PERLIN_SIZE];
    n2 += rxf*(perlin[(of+PERLIN_YWRAP+1)&PERLIN_SIZE]-n2);
    n1 += ryf*(n2-n1);

    of += PERLIN_ZWRAP;
    n2  = perlin[of&PERLIN_SIZE];
    n2 += rxf*(perlin[(of+1)&PERLIN_SIZE]-n2);
    n3  = perlin[(of+PERLIN_YWRAP)&PERLIN_SIZE];
    n3 += rxf*(perlin[(of+PERLIN_YWRAP+1)&PERLIN_SIZE]-n3);
    n2 += ryf*(n3-n2);

    n1 += noise_fsc(zf)*(n2-n1);

    r += n1*ampl;
    ampl *= perlin_amp_falloff;
    xi<<=1; 
    xf*=2;
    yi<<=1; 
    yf*=2;
    zi<<=1; 
    zf*=2;

    if (xf>=1.0f) { 
      xi++; 
      xf--;
    }
    if (yf>=1.0f) { 
      yi++; 
      yf--;
    }
    if (zf>=1.0f) { 
      zi++; 
      zf--;
    }
  }
  return r;
}

// [toxi 031112]
// now adjusts to the size of the cosLUT used via
// the new variables, defined above
private float noise_fsc(float i) {
  // using bagel's cosine table instead

  int index = (int)(i*perlin_PI)%perlin_TWOPI;
  float cosvalue = perlin_cosTable[index];

  // for a very precise cosinus, just un-comment this line (all cos table is uselless then you can remove it as well
  // cosvalue = cos(i*PI);

  return 0.5f*(1.0f-cosvalue);
}

// [toxi 040903]
// make perlin noise quality user controlled to allow
// for different levels of detail. lower values will produce
// smoother results as higher octaves are surpressed

/**
 * ( begin auto-generated from noiseDetail.xml )
 *
 * Adjusts the character and level of detail produced by the Perlin noise
 * function. Similar to harmonics in physics, noise is computed over
 * several octaves. Lower octaves contribute more to the output signal and
 * as such define the overal intensity of the noise, whereas higher octaves
 * create finer grained details in the noise sequence. By default, noise is
 * computed over 4 octaves with each octave contributing exactly half than
 * its predecessor, starting at 50% strength for the 1st octave. This
 * falloff amount can be changed by adding an additional function
 * parameter. Eg. a falloff factor of 0.75 means each octave will now have
 * 75% impact (25% less) of the previous lower octave. Any value between
 * 0.0 and 1.0 is valid, however note that values greater than 0.5 might
 * result in greater than 1.0 values returned by <b>noise()</b>.<br /><br
 * />By changing these parameters, the signal created by the <b>noise()</b>
 * function can be adapted to fit very specific needs and characteristics.
 *
 * ( end auto-generated )
 * @webref math:random
 * @param lod number of octaves to be used by the noise
 * @see PApplet#noise(float, float, float)
 */
public void noiseDetail(int lod) {
  if (lod>0) perlin_octaves=lod;
}

/**
 * @see #noiseDetail(int)
 * @param falloff falloff factor for each octave
 */
public void noiseDetail(int lod, float falloff) {
  if (lod>0) perlin_octaves=lod;
  if (falloff>0) perlin_amp_falloff=falloff;
}

/**
 * ( begin auto-generated from noiseSeed.xml )
 *
 * Sets the seed value for <b>noise()</b>. By default, <b>noise()</b>
 * produces different results each time the program is run. Set the
 * <b>value</b> parameter to a constant to return the same pseudo-random
 * numbers each time the software is run.
 *
 * ( end auto-generated )
 * @webref math:random
 * @param seed seed value
 * @see PApplet#noise(float, float, float)
 * @see PApplet#noiseDetail(int, float)
 * @see PApplet#random(float,float)
 * @see PApplet#randomSeed(long)
 */
public void noiseSeed(long seed) {
  if (perlinRandom == null) perlinRandom = new Random();
  perlinRandom.setSeed(seed);
  // force table reset after changing the random number seed [0122]
  perlin = null;
}


  public void settings() { size(1200, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "MyStippleGen" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
