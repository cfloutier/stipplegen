/* autogenerated by Processing revision 1293 on 2024-07-21 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import controlP5.*;
import processing.pdf.*;
import processing.dxf.*;
import processing.svg.*;
import controlP5.*;
import controlP5.*;
import java.util.Random;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class MyStippleGen extends PApplet {

/**

 StippleGen_3

 SVG Stipple Generator, v. 3.0
 Copyright (C) 2024 by Christophe Floutier

 based on :
 
 SVG Stipple Generator, v. 2.50
 Copyright (C) 2019 by Windell H. Oskay, www.evilmadscientist.com

 Full Documentation: http://wiki.evilmadscientist.com/StippleGen
 Blog post about the release: http://www.evilmadscientist.com/go/stipple2

 An implementation of Weighted Voronoi Stippling:
 http://mrl.nyu.edu/~ajsecord/stipples.html

 *******************************************************************************


/*  
 * 
 * This is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * http://creativecommons.org/licenses/LGPL/2.1/
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */





 
DataGlobal data;
DataGUI dataGui;
DrawingGenerator drawer;


//SourceFiles sourceFilesGui;
PGraphics current_graphics;

ControlP5 cp5;

public void setup() 
{
  /* size commented out by preprocessor */;

  drawer =  new DrawingGenerator();

  data = new DrawingData();
  dataGui = new DataGUI(data);
  
  setupControls();
   
  data.LoadJson("./Settings/default.json");
  data.name = "default";

  dataGui.setGUIValues();
  surface.setResizable(true);
}

public void setupControls()
{ 
  cp5 = new ControlP5(this);  //<>//
  cp5.getTab("default").setLabel("Hide GUI");

  dataGui.setupControls( );     
  addFileTab();
}

public void draw()
{
  start_draw();

  if (data.changed)
  {
    dataGui.updateUI();
  }
  
  //drawer.center = new PVector(width/2, height/2);

  //drawer.draw();

  end_draw();
}
  
class DataGUI
{
  public DataGUI(DrawingData data)
  {
    this.data = data;
    images_ui = new ImageGUI(data.image); 
    dots_ui = new DotGUI(data.dots); 
  }

  DrawingData data;
  ImageGUI images_ui;
  DotGUI dots_ui;

  public void updateUI()
  {
    if (!data.changed)
      return;

    images_ui.update();
    dots_ui.update();  
  }

  public void setupControls()
  { 
    cp5.addTab("Image");
    cp5.addTab("Dots");

    images_ui.setupControls(  ) ;
    dots_ui.setupControls(  );   
    
    cp5.getTab("Dots").bringToFront();
  }
  
  public void setGUIValues()
  {
    images_ui.setGUIValues();
    dots_ui.setGUIValues();
  }
}

class DotGUI extends GUIPanel
{   
    Slider CellSize;
    Slider DotDensity;
    Toggle Black;
    Toggle drawCells;
    
    public void setupControls()
    {    
        super.Init("Dots");
        
        Black = addToggle("Black", "Black Dots", data); 
        
        nextLine();  
        drawCells = addToggle("drawCells", "Draw Cells", data); 
        
        CellSize = addSlider("CellSize", "Cell Size", data, 2, 40, true);          
        DotDensity = addSlider("DotDensity", "Dots Density", data, 1, 40, true);       
    }
    
    public void update()        
    {
        
    }

    public void setGUIValues()
    {
        CellSize.setValue(data.CellSize);
        DotDensity.setValue(data.DotDensity);
    }
}

class ImageGUI extends GUIPanel
{ 
    DataImage data;

    public ImageGUI(DataImage data)
    {
      this.data = data;
    }

    public void update()
    {   
        if (data.source_file == "")
            file_Label.setText("please select a file");
        else
            file_Label.setText(data.source_file);
    }
    
    Slider Width;
    Slider ImageAlpha;
    Slider Blur;
    
    Textlabel file_Label;
    
    public void setupControls()
    {   
        super.Init("Image");
        
        addButton("SelectSourceImage");
        file_Label = addLabel("File Label");            
        nextLine();
        
        Width = addSlider("Width", "Width", data, 200, 2000, true); 
        ImageAlpha = addSlider("ImageAlpha", "Image Alpha", data, 0, 255, true);
        
        Blur = addIntSlider("Blur", "Blur", data, 1, 20, true);
        
       // updateUI();
    }

    public void setGUIValues()
    {
        Width.setValue(data.Width);
        ImageAlpha.setValue(data.ImageAlpha);
        Blur.setValue(data.Blur);
    }
    
}
 

class DataDots
{
    boolean Black = false;
    float CellSize = 4;
    float DotDensity = 10;
    int seed = 0;
    
    boolean drawCells = false;


    public void LoadJson(JSONObject src)
    {
        Black = src.getBoolean("Black", Black);
        CellSize = src.getFloat("CellSize", CellSize);
        DotDensity = src.getFloat("DotDensity", DotDensity);
        seed = src.getInt("seed", seed);    
    }

    public JSONObject SaveJson()
    {
        JSONObject dest = new JSONObject();

        backgroundColor.SaveJson(dest);
        lineColor.SaveJson(dest);

        dest.setBoolean("Black", Black);
        dest.setFloat("CellSize", CellSize);
        dest.setInt("DotDensity", DotDensity);

        return dest;
    }
}

class DataGlobal
{
    String name = "";
    
    
    DataImage image = new DataImage();
    DataDots dots = new DataDots();
    Style style = new Style();

    //this field is modified by the UIPanel
    //on any UI change
    boolean changed = true;
    
    float width = 800;
    float height = 600;
    
    public void setSize(float width, float height)
    {
        if (this.width != width)
        {
            changed = true;
            this.width = width;
        }
        
        if (this.height != height)
        {
            changed = true;
            this.height = height;
        }
    }
    
    public String sketch_name()
    {
        return image.source_file.substring(0, image.source_file.length() - 4);  
    }  



  public void LoadJson(String path)
  {
    print("path" + path);
    
    JSONObject json = loadJSONObject(path);

    
    image.LoadJson(json.getJSONObject("Image"));
    dots.LoadJson(json.getJSONObject("Dots"));
    style.LoadJson(json.getJSONObject("Style"));
  }

  public void SaveJson(String path)
  {
    JSONObject json = new JSONObject();

    json.setJSONObject("Style", style.SaveJson());
    json.setJSONObject("Image", image.SaveJson());
    json.setJSONObject("Dots", dots.SaveJson());

    saveJSONObject(json, path);
  }
    
    public void LoadJson(JSONObject src)
    {
        CellSize = src.getFloat("CellSize", CellSize);
        DotDensity = src.getFloat("DotDensity", DotDensity);
        seed = src.getInt("seed", seed);    
    }
    
    public void SaveJson(String path)
    {
        JSONObject dest = new JSONObject();
        
        dest.setFloat("CellSize", CellSize);
        dest.setFloat("DotDensity", DotDensity);
        dest.setInt("seed", seed);

        saveJSONObject(dest, path);
    }
    
}
class DataImage
{
    String source_file = "eye.jpg";

    float Width = 500;
    float ImageAlpha = 0;
    int   Blur = 2; 
    int Contrast = 0;

    PImage image = null;

    public void setImage(String source_file)
    {
        this.source_file = source_file;
        image = loadImage(source_file);
        image.filter(GRAY);


        //image.filter(BLUR, 20);
    }

    // computed
    public float Height()
    {
        if (image == null)
            return 0;
        
        return image.height * Width / image.width;
    }

    public void LoadJson(JSONObject src)
    {
        Width = src.getFloat("Width", Width);  
        
        ImageAlpha = src.getFloat("ImageAlpha", ImageAlpha);
        Blur = src.getInt("Blur", Blur);
        Contrast = src.getInt("Contrast", Contrast);
        
        setImage(src.getString("source_file", source_file));
    }

    public JSONObject SaveJson()
    {
        JSONObject dest = new JSONObject();

        dest.setFloat("Width", Width);    
        dest.setString("source_file", source_file);

        dest.setFloat("ImageAlpha", ImageAlpha);
        dest.setInt("Blur", Blur);
        dest.setFloat("Contrast", Contrast);

        return dest;
    }
}


class Cell
{
    DrawingData data;
    PVector pos;
    float value;
    Cell(DrawingData data, PVector pos, float value)
    {
      this.data =  data;
      this.pos = pos;
      this.value = value;
    }
    
    public void drawSquare(DrawingGenerator drawer)
    {
        PVector center = new PVector(pos.x + drawer.start_pos.x , pos.y + drawer.start_pos.y);
        float mid_size = data.CellSize/2;
        //println("pos.y " + pos.y);
        fill(value);
        strokeWeight(0);
        square(center.x-mid_size, center.y-mid_size, data.CellSize);
    }
    
    public void BuildPoints(DrawingGenerator drawer)
    {
      int nb_points = 0;
      if (!data.Black)
      {
        nb_points = round(value / 255.0f * data.DotDensity);
      }
      else
      {
        nb_points = round((1-value / 255.0f) * data.DotDensity);
      }
      
      //println(nb_points);
      
      PVector center = new PVector(pos.x + drawer.start_pos.x , pos.y + drawer.start_pos.y);
      float mid_size = data.CellSize/2;
      for (int i = 0; i < nb_points; i++)
      {       
          PVector pos = new PVector(center.x + random(-mid_size, mid_size), center.y+ random(-mid_size, mid_size));       
          drawer.points.add(pos);
      }
      
      
    }
}



class DrawingGenerator
{
   DrawingGenerator()
   {
     
   }

    ArrayList<Cell> cells =  new ArrayList<Cell>();
    ArrayList<PVector> points =  new ArrayList<PVector>();
    
    float last_blur = 0;
    float last_width = 0;
    PImage blurred_image = null;
    
    public void buildBlurredImage()
    {
      if (last_blur != data.Blur || 
          last_width != data.Width ||   
          blurred_image == null)
      {
        blurred_image = data.image.copy();
        blurred_image.resize((int)data.Width, (int)data.Height());
        blurred_image.filter(BLUR, data.Blur);
        
        println("build blur");

        last_blur = data.Blur;
        last_width = data.Width;
        
        cells.clear();     
      }
    }
    
    int Height;
    public int pixelIndex(float xPos, float yPos)
    {    
        return round(xPos) + round(yPos * Height);
    }
    
    PVector start_pos;
    
    float last_CellSize = 0;
    
    public void buildCells(PVector center)
    {
        if (last_CellSize != data.CellSize || 
            cells.size() == 0)
        {
               cells.clear();
               println("build cells");
        
            float xPos = data.CellSize/2;
            float yPos = data.CellSize/2;
            
            Height = round(data.Height());
            start_pos = new PVector(center.x - data.Width/2, center.y - data.Height()/2);
            
            while( yPos < Height)
            {
              while( xPos < data.Width)
              {
                float value = red(blurred_image.get((int)xPos, (int)yPos));
                Cell cell = new Cell(data, new PVector(xPos, yPos), value); 
                cells.add(cell);
                xPos += data.CellSize;
              }
    
              yPos += data.CellSize;
              xPos = data.CellSize/2;
            }      
            
            points.clear();
            
            last_CellSize = data.CellSize;           
       }    
    }
    
    public void drawCells()
    {
       for (int i =0 ; i < cells.size(); i++) 
         cells.get(i).drawSquare(this);
    }
    
    
    float last_DotDensity = 0;
   
    public void buildPoints()
    {
         if (last_DotDensity  != data.DotDensity || 
            points.size() == 0)
        {
          
          points.clear();
          randomSeed(data.seed);
          println("build points");
          
          
          for (int i =0 ; i < cells.size(); i++) 
          {     
             cells.get(i).BuildPoints(this);
          }
          
          last_DotDensity = data.DotDensity;
          
        }
    }
    
    public void drawPoints()
    {
      strokeWeight(0);
      if (data.Black)
         fill(0);
       else
         fill(255);
      
      for (int i =0 ; i < points.size(); i++) 
      {
         var pos = points.get(i);
         circle(pos.x, pos.y, 4); 
      }
         
    
    }
    
        /*int steps = data.NbSteps * data.NbStepsMultiplier;
        
        if(steps < 2)
        steps = 2;
        
        if(data.NbLines < 1)
        data.NbSteps = 1;
        
        
        float angle = 0;
        float deltaAngle = 360.0 / data.NbLines;
        float rotation =  data.Rotation *  data.RotationMultiplier + data.Rotation * data.RotationTwitch/100;
        
        for (int line = 0 ; line < data.NbLines; line ++)
        {        
        angle = deltaAngle*line + data.StartAngle;
        drawOneLine(steps, angle, rotation);
    }
        
        if (data.Mirror)
        {
        
        rotation = - rotation;
        for (int line = 0 ; line < data.NbLines; line ++)
        {
        
        angle = deltaAngle*line+ data.StartAngle;
        drawOneLine(steps, angle, rotation);
        }
    }*/
}



class Style
{
  ColorRef lineColor = new ColorRef(color(255, 255, 255), "lineColor");
  ColorRef backgroundColor = new ColorRef(color(0, 0, 0), "backgroundColor");
  float lineWidth = 1;

  public void LoadJson(JSONObject src)
  {
    if (src == null)
      return;

    backgroundColor.LoadJson(src);
    lineColor.LoadJson(src);

    lineWidth = src.getFloat("lineWidth", lineWidth);
  }

  public JSONObject SaveJson()
  {
    JSONObject dest = new JSONObject();

    backgroundColor.SaveJson(dest);
    lineColor.SaveJson(dest);

    dest.setFloat("lineWidth", lineWidth);

    return dest;
  }
}


class StyleGUI extends GUIPanel
{
  Slider lineWidth;
  Style style;
  ColorGroup backgroundColor;
  ColorGroup lineColor;

  public void setGUIValues()
  {
    lineWidth.setValue(style.lineWidth);
  }

  public void setupControls()
  {
    style = data.style;
    super.Init("Style");
    lineWidth = addSlider("lineWidth", "Line Width", style, 0, 5, false);
    lineColor = addColorGroup("Line Color", style.lineColor);
    backgroundColor = addColorGroup("background Color", style.backgroundColor);
  }

  public void update()
  {
 
  }
}

class ColorButton
{
  int col;

  Button bt = null;
  ColorRef refColor = null;

  ColorButton(int col)
  {
    this.col = col;
  }

  public void init(GUIPanel panel, ColorRef refColor)
  {
    bt = cp5.addButton("colorbt"+ indexControler)
      .setPosition(panel.xPos, panel.yPos)
      .setSize(20, 20)
      .setLabel("")
      .moveTo(panel.pageName)
      .setColorBackground(col);

    indexControler++;
    panel.xPos += 22;


    bt.plugTo(this, "onCLic");
    this.refColor = refColor;
  }

  public void onCLic()
  {
    refColor.col = this.col;
  }
}

class ColorGroup
{
  ColorRef colorRef;
  String name;

  int[][] colors = {
    { 255, 255, 255  },
  
    { 255, 205, 210 }, // rose
    
    { 81, 46, 95   }, 
    { 155, 89, 182  }, 
    { 235, 222, 240 }, 
    { 21, 67, 96 }, 
    { 127, 179, 213 }, 
    { 33, 97, 140 }, 
    { 93, 173, 226 }, 
    { 14, 98, 81 }, 
    { 39, 174, 96 }, 
    { 88, 214, 141 }, 
    
    { 255, 245, 157 }, // jaunes
    { 253, 216, 53  }, 
      
    { 251, 140, 0},  // orange
    { 255, 87, 34 },  // 
    {  191, 54, 12   },  // rouges
    { 100, 30, 22 }, 
    { 192, 57, 43 }, 
    { 148, 49, 38  }, 
    
    { 93, 64, 55  }, //marrons
    { 62, 39, 35  }, 

    
    { 174, 182, 191 }, // gris
    { 44, 62, 80 }, 
    { 23, 32, 42 }, 
    { 10, 14, 19 }, 
    { 0, 0, 0  }
  };

  ColorGroup(ColorRef colorRef, String name)
  {
    this.colorRef = colorRef;
    this.name = name;
  }

  public void Init(GUIPanel panel)
  {
    panel.addLabel(name);
    
    for(int i = 0; i< colors.length; i++){
        if (i != 0 && (i%8) == 0)
        {
          panel.yPos += 25;
          panel.xPos = StartX;
        }
        
        int[] colorValues = colors[i];
        new ColorButton(color(colorValues[0], colorValues[1],colorValues[2])).init(panel, colorRef);
        
    }
    
     panel.yPos += 25;
     panel.xPos = StartX;
  }
}


class ColorRef
{
  ColorRef(int col, String name)
  {
    this.col = col;
    this.name = name;
  }

  int col;
  String name;

  public void LoadJson(JSONObject src)
  {
    col = src.getInt(name, col);
  }

  public void SaveJson(JSONObject dest)
  {
    dest.setInt(name, col);
  }
}

public void addFileTab()
{
  cp5.addTab("Files");
  
  println("addFileTab");

  float xPos = 0;
  float yPos = 20;

  int widthButton = 100;
  int heightButton = 20;

  cp5.addButton("LoadJson")
    .setPosition(xPos, yPos)
    .setSize(widthButton, heightButton)
    .moveTo("Files");        

  xPos += widthButton;

  cp5.addButton("SaveJson")
    .setPosition(xPos, yPos)
    .setSize(widthButton, heightButton)
    .moveTo("Files");    

  yPos += heightButton;
  xPos = 0;

  cp5.addButton("ExportPDF")
    .setPosition(xPos, yPos)
    .setSize(widthButton, heightButton)
    .moveTo("Files");      

  xPos += widthButton;

/*  cp5.addButton("ExportDXF")
    .setPosition(xPos, yPos)
    .setSize(widthButton, heightButton)
    .moveTo("Files");      

  xPos += widthButton;
*/

  cp5.addButton("ExportSVG")
    .setPosition(xPos, yPos)
    .setSize(widthButton, heightButton)
    .moveTo("Files");    

  xPos += widthButton;
}

public void LoadJson()
{
  print("LoadJson");
  
  File file = new File(".");
  selectInput("Select data file ", "loadSelected", file);
}

public void loadSelected(File selection) 
{
  if (selection == null) 
  {
  } else 
  {
    data.LoadJson(selection.getAbsolutePath());
    data.name = selection.getName();
    data.name = data.name.substring(0, data.name.length() - 5);
   
    dataGui.setGUIValues();
  }
}

public void SaveJson()
{
  selectInput("Save data file ", "saveSelected");
}

public void saveSelected(File selection) 
{
  if (selection == null) 
  {
  } else 
  {
    String path = selection.getAbsolutePath();
    if (path.length() < 5 || !path.substring(path.length() - 5).equals(".json"))
      path = path + ".json";

    data.SaveJson(path);
    
    data.name = selection.getName();
    data.name = data.name.substring(0, data.name.length() - 5);
  
  }
}

boolean record = false;
int mode  = 0;

String fileName = "";
public void ExportPDF()
{
  record = true;
  mode = 0;
}

public void ExportDXF()
{
  record = true;
  mode = 1;
}  

public void ExportSVG()
{
  record = true;
  mode = 2;
}

public void start_draw()
{
  if (record) 
  {

    String name = data.name;
    if (name == "")
      name = "Perlin_Mountain";
      
    float sizeMultiplier = 1;
    
    println(name);
      
   // sizeMultiplier = (float) width  / 28;
      
      
    float newWidth = width * sizeMultiplier;
    float newheight = height * sizeMultiplier;
      
    fileName = "Export/"+ name + "_" + year() + "-" + month() + "-" + day() + "_" + hour() + "-" + minute() + "-" + second(); 
    
    if (mode == 0)
       current_graphics = createGraphics((int)newWidth, (int)newheight, PDF, fileName+ ".pdf");       
    else if (mode == 1)
      current_graphics = createGraphics((int)newWidth, (int)newheight, DXF, fileName+ ".dxf");       
    else if (mode ==2)
      current_graphics = createGraphics((int)newWidth, (int)newheight, SVG, fileName+ ".svg");       
    
    data.setSize(newWidth, newheight); 
    
    current_graphics.beginDraw();
    current_graphics.strokeWeight(data.style.lineWidth*sizeMultiplier);
    
    current_graphics.rotate(-PI/2);
   
     current_graphics.translate(-newWidth,newheight/2);
    
    
  } else {
    
    current_graphics = g;

    background(data.style.backgroundColor.col);
    strokeWeight(data.style.lineWidth);

    stroke(data.style.lineColor.col);
    
    current_graphics = g;

    data.setSize(width, height);
  } 
}

public void end_draw()
{
  if (record) 
  {
    current_graphics.dispose();
    current_graphics.endDraw();
    record = false;
  }
}

int indexControler = 0;

static final int StartX = 20;
static final int StartY = 20;

class GUIPanel implements ControlListener
{
  String pageName;
  
  float xPos = 0;
  float yPos = 0;

  int xspace = 15;

  int widthCtrl = 300;
  int heightCtrl = 20;

  public void Init(String pageName)
  {
    this.pageName = pageName;
    
    cp5.addListener(this);

    yPos = StartY;
    xPos = StartX;
  }

  public void onUIChanged()
  {
    data.changed = true;
  }

  public void controlEvent(ControlEvent theEvent) {
    onUIChanged();
  }

  public Textlabel addLabel(String content)
  {
    yPos += 10;

    Textlabel l = cp5.addTextlabel("Label" + indexControler)
      .setText(content)
      .setPosition(xPos, yPos)
      .setSize(100, heightCtrl)
      .moveTo(pageName);

    yPos += 15;

    indexControler++;

    return l;
  }


  public Slider addIntSlider(String field, String label, Object data_Class, int min, int max, boolean horizontal)
  {
    Slider s = addSlider( field, label, data_Class, min, max, horizontal);
    int nbTicks = (int) (max - min + 1);
    s.setNumberOfTickMarks(nbTicks);
    s.showTickMarks(false);
    s.snapToTickMarks(true);

    return s;
  }


  public Slider addSlider(String field, String label, Object data_Class, float min, float max, boolean horizontal)
  {
    Slider s = cp5.addSlider(data_Class, field)
      .setLabel(label)
      .setPosition(xPos, yPos)
      .setSize(widthCtrl, heightCtrl)
      .setRange(min, max)
      .moveTo(pageName);

    if (horizontal)
    {
      xPos += xspace + widthCtrl;
    } else
    {
      yPos+=heightCtrl+2;
      xPos = StartX;
    }

    controlP5.Label l = s.getCaptionLabel();
    l.getStyle().marginTop = 0; //move upwards (relative to button size)
    l.getStyle().marginLeft = -65; //move to the right

    return s;
  }

  public Toggle addToggle(String name, String label, Object data_Class)
  {
    Toggle t = cp5.addToggle(data_Class, name)
      .setLabel(label)
      .setPosition(xPos, yPos)
      .setSize(100, heightCtrl)
      .setMode(ControlP5.SWITCH)
      .moveTo(pageName);

    CColor controlerColor = t.getColor();
    int tmp = controlerColor.getActive();
    controlerColor.setActive( controlerColor.getBackground());
    controlerColor.setBackground(tmp);

    yPos+=heightCtrl+2;

    //t.setLabel("The Toggle Name");
    controlP5.Label l = t.getCaptionLabel();
    l.getStyle().marginTop = -heightCtrl + 2; //move upwards (relative to button size)
    l.getStyle().marginLeft = 10; //move to the right

    return t;
  }

  public ColorPicker addColorPicker(String name, String label, Object data_Class)
  {
    addLabel(label);

    ColorPicker cp = cp5.addColorPicker(data_Class, name)

      .setPosition(xPos, yPos)
      .setSize(100, heightCtrl*3)
      .moveTo(pageName);

    yPos+=heightCtrl*3;

    return cp;
  }


  public ColorGroup addColorGroup(String name, ColorRef colorRef)
  {
    ColorGroup grp = new ColorGroup(colorRef, name );

    grp.Init(this);

    return grp;
  }

  public Button addButton(String name)
  {
    Button bt = cp5.addButton(name + indexControler)
      .setPosition(xPos, yPos)
      .setLabel(name)
      .setSize(100, heightCtrl)
      .moveTo(pageName);

    indexControler++;
    yPos+=heightCtrl+5;

    return bt;
  }
  
  public void start()
  {
    xPos = 20;
    yPos = 20;
  }
  
  public void nextLine()
  {
    xPos = 20;
    yPos += heightCtrl + 1;
    
    }
}




//////////////////////////////////////////////////////////////

// PERLIN NOISE, rewriten by cfloutier to change the way cosinus is computed

// [toxi 040903]
// octaves and amplitude amount per octave are now user controlled
// via the noiseDetail() function.

// [toxi 030902]
// cleaned up code and now using bagel's cosine table to speed up

// [toxi 030901]
// implementation by the german demo group farbrausch
// as used in their demo "art": http://www.farb-rausch.de/fr010src.zip

static final int PERLIN_YWRAPB = 4;
static final int PERLIN_YWRAP = 1<<PERLIN_YWRAPB;
static final int PERLIN_ZWRAPB = 8;
static final int PERLIN_ZWRAP = 1<<PERLIN_ZWRAPB;
static final int PERLIN_SIZE = 4095;

int perlin_octaves = 4; // default to medium smooth
float perlin_amp_falloff = 0.5f; // 50% reduction/octave

// [toxi 031112]
// new vars needed due to recent change of cos table in PGraphics
int perlin_PI;
static final int perlin_TWOPI = 65536;

float[] perlin_cosTable;
float[] perlin;

Random perlinRandom;

/**
 */
public float noise(float x) {
  // is this legit? it's a dumb way to do it (but repair it later)
  return noise(x, 0f, 0f);
}

/**
 */
public float noise(float x, float y) {
  return noise(x, y, 0f);
}


/**
 * ( begin auto-generated from noise.xml )
 *
 * Returns the Perlin noise value at specified coordinates. Perlin noise is
 * a random sequence generator producing a more natural ordered, harmonic
 * succession of numbers compared to the standard <b>random()</b> function.
 * It was invented by Ken Perlin in the 1980s and been used since in
 * graphical applications to produce procedural textures, natural motion,
 * shapes, terrains etc.<br /><br /> The main difference to the
 * <b>random()</b> function is that Perlin noise is defined in an infinite
 * n-dimensional space where each pair of coordinates corresponds to a
 * fixed semi-random value (fixed only for the lifespan of the program).
 * The resulting value will always be between 0.0 and 1.0. Processing can
 * compute 1D, 2D and 3D noise, depending on the number of coordinates
 * given. The noise value can be animated by moving through the noise space
 * as demonstrated in the example above. The 2nd and 3rd dimension can also
 * be interpreted as time.<br /><br />The actual noise is structured
 * similar to an audio signal, in respect to the function's use of
 * frequencies. Similar to the concept of harmonics in physics, perlin
 * noise is computed over several octaves which are added together for the
 * final result. <br /><br />Another way to adjust the character of the
 * resulting sequence is the scale of the input coordinates. As the
 * function works within an infinite space the value of the coordinates
 * doesn't matter as such, only the distance between successive coordinates
 * does (eg. when using <b>noise()</b> within a loop). As a general rule
 * the smaller the difference between coordinates, the smoother the
 * resulting noise sequence will be. Steps of 0.005-0.03 work best for most
 * applications, but this will differ depending on use.
 *
 * ( end auto-generated )
 *
 * @webref math:random
 * @param x x-coordinate in noise space
 * @param y y-coordinate in noise space
 * @param z z-coordinate in noise space
 * @see PApplet#noiseSeed(long)
 * @see PApplet#noiseDetail(int, float)
 * @see PApplet#random(float,float)
 */
public float noise(float x, float y, float z) {
  if (perlin == null) {
    if (perlinRandom == null) {
      perlinRandom = new Random();
    }
    perlin = new float[PERLIN_SIZE + 1];
    for (int i = 0; i < PERLIN_SIZE + 1; i++) {
      perlin[i] = perlinRandom.nextFloat(); //(float)Math.random();
    }

    perlin_cosTable = new float[perlin_TWOPI];
    perlin_PI = perlin_TWOPI >> 1;
    for (int i = 0; i < perlin_TWOPI; i++)
    {
      float angle = (float)i/perlin_PI;

      perlin_cosTable[i] =  cos( angle * PI );
    }
  }

  if (x<0) x=-x;
  if (y<0) y=-y;
  if (z<0) z=-z;

  int xi=(int)x, yi=(int)y, zi=(int)z; //<>//
  float xf = x - xi;
  float yf = y - yi;
  float zf = z - zi;
  float rxf, ryf;

  float r=0;
  float ampl=0.5f;

  float n1, n2, n3;

  for (int i=0; i<perlin_octaves; i++) {
    int of=xi+(yi<<PERLIN_YWRAPB)+(zi<<PERLIN_ZWRAPB);

    rxf=noise_fsc(xf);
    ryf=noise_fsc(yf);

    n1  = perlin[of&PERLIN_SIZE];
    n1 += rxf*(perlin[(of+1)&PERLIN_SIZE]-n1);
    n2  = perlin[(of+PERLIN_YWRAP)&PERLIN_SIZE];
    n2 += rxf*(perlin[(of+PERLIN_YWRAP+1)&PERLIN_SIZE]-n2);
    n1 += ryf*(n2-n1);

    of += PERLIN_ZWRAP;
    n2  = perlin[of&PERLIN_SIZE];
    n2 += rxf*(perlin[(of+1)&PERLIN_SIZE]-n2);
    n3  = perlin[(of+PERLIN_YWRAP)&PERLIN_SIZE];
    n3 += rxf*(perlin[(of+PERLIN_YWRAP+1)&PERLIN_SIZE]-n3);
    n2 += ryf*(n3-n2);

    n1 += noise_fsc(zf)*(n2-n1);

    r += n1*ampl;
    ampl *= perlin_amp_falloff;
    xi<<=1; 
    xf*=2;
    yi<<=1; 
    yf*=2;
    zi<<=1; 
    zf*=2;

    if (xf>=1.0f) { 
      xi++; 
      xf--;
    }
    if (yf>=1.0f) { 
      yi++; 
      yf--;
    }
    if (zf>=1.0f) { 
      zi++; 
      zf--;
    }
  }
  return r;
}

// [toxi 031112]
// now adjusts to the size of the cosLUT used via
// the new variables, defined above
private float noise_fsc(float i) {
  // using bagel's cosine table instead

  int index = (int)(i*perlin_PI)%perlin_TWOPI;
  float cosvalue = perlin_cosTable[index];

  // for a very precise cosinus, just un-comment this line (all cos table is uselless then you can remove it as well
  // cosvalue = cos(i*PI);

  return 0.5f*(1.0f-cosvalue);
}

// [toxi 040903]
// make perlin noise quality user controlled to allow
// for different levels of detail. lower values will produce
// smoother results as higher octaves are surpressed

/**
 * ( begin auto-generated from noiseDetail.xml )
 *
 * Adjusts the character and level of detail produced by the Perlin noise
 * function. Similar to harmonics in physics, noise is computed over
 * several octaves. Lower octaves contribute more to the output signal and
 * as such define the overal intensity of the noise, whereas higher octaves
 * create finer grained details in the noise sequence. By default, noise is
 * computed over 4 octaves with each octave contributing exactly half than
 * its predecessor, starting at 50% strength for the 1st octave. This
 * falloff amount can be changed by adding an additional function
 * parameter. Eg. a falloff factor of 0.75 means each octave will now have
 * 75% impact (25% less) of the previous lower octave. Any value between
 * 0.0 and 1.0 is valid, however note that values greater than 0.5 might
 * result in greater than 1.0 values returned by <b>noise()</b>.<br /><br
 * />By changing these parameters, the signal created by the <b>noise()</b>
 * function can be adapted to fit very specific needs and characteristics.
 *
 * ( end auto-generated )
 * @webref math:random
 * @param lod number of octaves to be used by the noise
 * @see PApplet#noise(float, float, float)
 */
public void noiseDetail(int lod) {
  if (lod>0) perlin_octaves=lod;
}

/**
 * @see #noiseDetail(int)
 * @param falloff falloff factor for each octave
 */
public void noiseDetail(int lod, float falloff) {
  if (lod>0) perlin_octaves=lod;
  if (falloff>0) perlin_amp_falloff=falloff;
}

/**
 * ( begin auto-generated from noiseSeed.xml )
 *
 * Sets the seed value for <b>noise()</b>. By default, <b>noise()</b>
 * produces different results each time the program is run. Set the
 * <b>value</b> parameter to a constant to return the same pseudo-random
 * numbers each time the software is run.
 *
 * ( end auto-generated )
 * @webref math:random
 * @param seed seed value
 * @see PApplet#noise(float, float, float)
 * @see PApplet#noiseDetail(int, float)
 * @see PApplet#random(float,float)
 * @see PApplet#randomSeed(long)
 */
public void noiseSeed(long seed) {
  if (perlinRandom == null) perlinRandom = new Random();
  perlinRandom.setSeed(seed);
  // force table reset after changing the random number seed [0122]
  perlin = null;
}


  public void settings() { size(1200, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "MyStippleGen" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
